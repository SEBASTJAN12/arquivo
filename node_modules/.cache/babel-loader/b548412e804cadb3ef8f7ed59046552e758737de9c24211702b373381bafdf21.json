{"ast":null,"code":"import Combobox from '@github/combobox-nav';\nconst boundary = /\\s|\\(|\\[/;\nfunction query(text, key, cursor) {\n  let _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      multiWord: false,\n      lookBackIndex: 0,\n      lastMatchPosition: null\n    },\n    multiWord = _ref.multiWord,\n    lookBackIndex = _ref.lookBackIndex,\n    lastMatchPosition = _ref.lastMatchPosition;\n  let keyIndex = text.lastIndexOf(key, cursor - 1);\n  if (keyIndex === -1) return;\n  if (keyIndex < lookBackIndex) return;\n  if (multiWord) {\n    if (lastMatchPosition != null) {\n      if (lastMatchPosition === keyIndex) return;\n      keyIndex = lastMatchPosition - key.length;\n    }\n    const charAfterKey = text[keyIndex + 1];\n    if (charAfterKey === ' ' && cursor >= keyIndex + key.length + 1) return;\n    const newLineIndex = text.lastIndexOf('\\n', cursor - 1);\n    if (newLineIndex > keyIndex) return;\n    const dotIndex = text.lastIndexOf('.', cursor - 1);\n    if (dotIndex > keyIndex) return;\n  } else {\n    const spaceIndex = text.lastIndexOf(' ', cursor - 1);\n    if (spaceIndex > keyIndex) return;\n  }\n  const pre = text[keyIndex - 1];\n  if (pre && !boundary.test(pre)) return;\n  const queryString = text.substring(keyIndex + key.length, cursor);\n  return {\n    text: queryString,\n    position: keyIndex + key.length\n  };\n}\nconst properties = ['position:absolute;', 'overflow:auto;', 'word-wrap:break-word;', 'top:0px;', 'left:-9999px;'];\nconst propertyNamesToCopy = ['box-sizing', 'font-family', 'font-size', 'font-style', 'font-variant', 'font-weight', 'height', 'letter-spacing', 'line-height', 'max-height', 'min-height', 'padding-bottom', 'padding-left', 'padding-right', 'padding-top', 'border-bottom', 'border-left', 'border-right', 'border-top', 'text-decoration', 'text-indent', 'text-transform', 'width', 'word-spacing'];\nconst mirrorMap = new WeakMap();\nfunction textFieldMirror(textField, markerPosition) {\n  const nodeName = textField.nodeName.toLowerCase();\n  if (nodeName !== 'textarea' && nodeName !== 'input') {\n    throw new Error('expected textField to a textarea or input');\n  }\n  let mirror = mirrorMap.get(textField);\n  if (mirror && mirror.parentElement === textField.parentElement) {\n    mirror.innerHTML = '';\n  } else {\n    mirror = document.createElement('div');\n    mirrorMap.set(textField, mirror);\n    const style = window.getComputedStyle(textField);\n    const props = properties.slice(0);\n    if (nodeName === 'textarea') {\n      props.push('white-space:pre-wrap;');\n    } else {\n      props.push('white-space:nowrap;');\n    }\n    for (let i = 0, len = propertyNamesToCopy.length; i < len; i++) {\n      const name = propertyNamesToCopy[i];\n      props.push(`${name}:${style.getPropertyValue(name)};`);\n    }\n    mirror.style.cssText = props.join(' ');\n  }\n  const marker = document.createElement('span');\n  marker.style.cssText = 'position: absolute;';\n  marker.innerHTML = '&nbsp;';\n  let before;\n  let after;\n  if (typeof markerPosition === 'number') {\n    let text = textField.value.substring(0, markerPosition);\n    if (text) {\n      before = document.createTextNode(text);\n    }\n    text = textField.value.substring(markerPosition);\n    if (text) {\n      after = document.createTextNode(text);\n    }\n  } else {\n    const text = textField.value;\n    if (text) {\n      before = document.createTextNode(text);\n    }\n  }\n  if (before) {\n    mirror.appendChild(before);\n  }\n  mirror.appendChild(marker);\n  if (after) {\n    mirror.appendChild(after);\n  }\n  if (!mirror.parentElement) {\n    if (!textField.parentElement) {\n      throw new Error('textField must have a parentElement to mirror');\n    }\n    textField.parentElement.insertBefore(mirror, textField);\n  }\n  mirror.scrollTop = textField.scrollTop;\n  mirror.scrollLeft = textField.scrollLeft;\n  return {\n    mirror,\n    marker\n  };\n}\nfunction textFieldSelectionPosition(field) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : field.selectionEnd;\n  const _textFieldMirror = textFieldMirror(field, index),\n    mirror = _textFieldMirror.mirror,\n    marker = _textFieldMirror.marker;\n  const mirrorRect = mirror.getBoundingClientRect();\n  const markerRect = marker.getBoundingClientRect();\n  setTimeout(() => {\n    mirror.remove();\n  }, 5000);\n  return {\n    top: markerRect.top - mirrorRect.top,\n    left: markerRect.left - mirrorRect.left\n  };\n}\nconst states = new WeakMap();\nclass TextExpander {\n  constructor(expander, input) {\n    this.expander = expander;\n    this.input = input;\n    this.combobox = null;\n    this.menu = null;\n    this.match = null;\n    this.justPasted = false;\n    this.lookBackIndex = 0;\n    this.oninput = this.onInput.bind(this);\n    this.onpaste = this.onPaste.bind(this);\n    this.onkeydown = this.onKeydown.bind(this);\n    this.oncommit = this.onCommit.bind(this);\n    this.onmousedown = this.onMousedown.bind(this);\n    this.onblur = this.onBlur.bind(this);\n    this.interactingWithList = false;\n    input.addEventListener('paste', this.onpaste);\n    input.addEventListener('input', this.oninput);\n    input.addEventListener('keydown', this.onkeydown);\n    input.addEventListener('blur', this.onblur);\n  }\n  destroy() {\n    this.input.removeEventListener('paste', this.onpaste);\n    this.input.removeEventListener('input', this.oninput);\n    this.input.removeEventListener('keydown', this.onkeydown);\n    this.input.removeEventListener('blur', this.onblur);\n  }\n  dismissMenu() {\n    if (this.deactivate()) {\n      this.lookBackIndex = this.input.selectionEnd || this.lookBackIndex;\n    }\n  }\n  activate(match, menu) {\n    if (this.input !== document.activeElement) return;\n    this.deactivate();\n    this.menu = menu;\n    if (!menu.id) menu.id = `text-expander-${Math.floor(Math.random() * 100000).toString()}`;\n    this.expander.append(menu);\n    this.combobox = new Combobox(this.input, menu);\n    const _textFieldSelectionPo = textFieldSelectionPosition(this.input, match.position),\n      top = _textFieldSelectionPo.top,\n      left = _textFieldSelectionPo.left;\n    menu.style.top = `${top}px`;\n    menu.style.left = `${left}px`;\n    this.combobox.start();\n    menu.addEventListener('combobox-commit', this.oncommit);\n    menu.addEventListener('mousedown', this.onmousedown);\n    this.combobox.navigate(1);\n  }\n  deactivate() {\n    const menu = this.menu;\n    if (!menu || !this.combobox) return false;\n    this.menu = null;\n    menu.removeEventListener('combobox-commit', this.oncommit);\n    menu.removeEventListener('mousedown', this.onmousedown);\n    this.combobox.destroy();\n    this.combobox = null;\n    menu.remove();\n    return true;\n  }\n  onCommit(_ref2) {\n    let target = _ref2.target;\n    const item = target;\n    if (!(item instanceof HTMLElement)) return;\n    if (!this.combobox) return;\n    const match = this.match;\n    if (!match) return;\n    const beginning = this.input.value.substring(0, match.position - match.key.length);\n    const remaining = this.input.value.substring(match.position + match.text.length);\n    const detail = {\n      item,\n      key: match.key,\n      value: null\n    };\n    const canceled = !this.expander.dispatchEvent(new CustomEvent('text-expander-value', {\n      cancelable: true,\n      detail\n    }));\n    if (canceled) return;\n    if (!detail.value) return;\n    const value = `${detail.value} `;\n    this.input.value = beginning + value + remaining;\n    const cursor = beginning.length + value.length;\n    this.deactivate();\n    this.input.focus();\n    this.input.selectionStart = cursor;\n    this.input.selectionEnd = cursor;\n    this.lookBackIndex = cursor;\n    this.match = null;\n  }\n  onBlur() {\n    if (this.interactingWithList) {\n      this.interactingWithList = false;\n      return;\n    }\n    this.deactivate();\n  }\n  onPaste() {\n    this.justPasted = true;\n  }\n  async onInput() {\n    if (this.justPasted) {\n      this.justPasted = false;\n      return;\n    }\n    const match = this.findMatch();\n    if (match) {\n      this.match = match;\n      const menu = await this.notifyProviders(match);\n      if (!this.match) return;\n      if (menu) {\n        this.activate(match, menu);\n      } else {\n        this.deactivate();\n      }\n    } else {\n      this.match = null;\n      this.deactivate();\n    }\n  }\n  findMatch() {\n    const cursor = this.input.selectionEnd || 0;\n    const text = this.input.value;\n    if (cursor <= this.lookBackIndex) {\n      this.lookBackIndex = cursor - 1;\n    }\n    for (const _ref3 of this.expander.keys) {\n      const key = _ref3.key;\n      const multiWord = _ref3.multiWord;\n      const found = query(text, key, cursor, {\n        multiWord,\n        lookBackIndex: this.lookBackIndex,\n        lastMatchPosition: this.match ? this.match.position : null\n      });\n      if (found) {\n        return {\n          text: found.text,\n          key,\n          position: found.position\n        };\n      }\n    }\n  }\n  async notifyProviders(match) {\n    const providers = [];\n    const provide = result => providers.push(result);\n    const canceled = !this.expander.dispatchEvent(new CustomEvent('text-expander-change', {\n      cancelable: true,\n      detail: {\n        provide,\n        text: match.text,\n        key: match.key\n      }\n    }));\n    if (canceled) return;\n    const all = await Promise.all(providers);\n    const fragments = all.filter(x => x.matched).map(x => x.fragment);\n    return fragments[0];\n  }\n  onMousedown() {\n    this.interactingWithList = true;\n  }\n  onKeydown(event) {\n    if (event.key === 'Escape') {\n      this.match = null;\n      if (this.deactivate()) {\n        this.lookBackIndex = this.input.selectionEnd || this.lookBackIndex;\n        event.stopImmediatePropagation();\n        event.preventDefault();\n      }\n    }\n  }\n}\nclass TextExpanderElement extends HTMLElement {\n  get keys() {\n    const keysAttr = this.getAttribute('keys');\n    const keys = keysAttr ? keysAttr.split(' ') : [];\n    const multiWordAttr = this.getAttribute('multiword');\n    const multiWord = multiWordAttr ? multiWordAttr.split(' ') : [];\n    const globalMultiWord = multiWord.length === 0 && this.hasAttribute('multiword');\n    return keys.map(key => ({\n      key,\n      multiWord: globalMultiWord || multiWord.includes(key)\n    }));\n  }\n  connectedCallback() {\n    const input = this.querySelector('input[type=\"text\"], textarea');\n    if (!(input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement)) return;\n    const state = new TextExpander(this, input);\n    states.set(this, state);\n  }\n  disconnectedCallback() {\n    const state = states.get(this);\n    if (!state) return;\n    state.destroy();\n    states.delete(this);\n  }\n  dismiss() {\n    const state = states.get(this);\n    if (!state) return;\n    state.dismissMenu();\n  }\n}\nif (!window.customElements.get('text-expander')) {\n  window.TextExpanderElement = TextExpanderElement;\n  window.customElements.define('text-expander', TextExpanderElement);\n}\nexport default TextExpanderElement;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}