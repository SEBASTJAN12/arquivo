{"ast":null,"code":"function insertText(textarea, text) {\n  var _a, _b, _c;\n  const before = textarea.value.slice(0, (_a = textarea.selectionStart) !== null && _a !== void 0 ? _a : undefined);\n  const after = textarea.value.slice((_b = textarea.selectionEnd) !== null && _b !== void 0 ? _b : undefined);\n  let canInsertText = true;\n  textarea.contentEditable = 'true';\n  try {\n    canInsertText = document.execCommand('insertText', false, text);\n  } catch (error) {\n    canInsertText = false;\n  }\n  textarea.contentEditable = 'false';\n  if (canInsertText && !textarea.value.slice(0, (_c = textarea.selectionStart) !== null && _c !== void 0 ? _c : undefined).endsWith(text)) {\n    canInsertText = false;\n  }\n  if (!canInsertText) {\n    try {\n      document.execCommand('ms-beginUndoUnit');\n    } catch (e) {}\n    textarea.value = before + text + after;\n    try {\n      document.execCommand('ms-endUndoUnit');\n    } catch (e) {}\n    textarea.dispatchEvent(new CustomEvent('change', {\n      bubbles: true,\n      cancelable: true\n    }));\n  }\n}\nconst skipFormattingMap = new WeakMap();\nfunction setSkipFormattingFlag(event) {\n  const el = event.currentTarget;\n  const isSkipFormattingKeys = event.code === 'KeyV' && (event.ctrlKey || event.metaKey) && event.shiftKey;\n  if (isSkipFormattingKeys || isSkipFormattingKeys && event.altKey) {\n    skipFormattingMap.set(el, true);\n  }\n}\nfunction unsetSkipFormattedFlag(event) {\n  const el = event.currentTarget;\n  skipFormattingMap.delete(el);\n}\nfunction shouldSkipFormatting(el) {\n  var _a;\n  const shouldSkipFormattingState = (_a = skipFormattingMap.get(el)) !== null && _a !== void 0 ? _a : false;\n  return shouldSkipFormattingState;\n}\nfunction installAround(el, installCallbacks, optionConfig) {\n  el.addEventListener('keydown', setSkipFormattingFlag);\n  for (const installCallback of installCallbacks) {\n    installCallback(el, optionConfig);\n  }\n  el.addEventListener('paste', unsetSkipFormattedFlag);\n}\nfunction uninstall$5(el) {\n  el.removeEventListener('keydown', setSkipFormattingFlag);\n  el.removeEventListener('paste', unsetSkipFormattedFlag);\n}\nfunction install$4(el) {\n  el.addEventListener('paste', onPaste$4);\n}\nfunction uninstall$4(el) {\n  el.removeEventListener('paste', onPaste$4);\n}\nfunction onPaste$4(event) {\n  const transfer = event.clipboardData;\n  const el = event.currentTarget;\n  if (shouldSkipFormatting(el)) return;\n  if (!transfer || !hasHTML(transfer)) return;\n  const field = event.currentTarget;\n  if (!(field instanceof HTMLTextAreaElement)) return;\n  if (isWithinUserMention(field)) {\n    return;\n  }\n  let plaintext = transfer.getData('text/plain');\n  const textHTML = transfer.getData('text/html');\n  const textHTMLClean = textHTML.replace(/\\u00A0/g, ' ').replace(/\\uC2A0/g, ' ');\n  if (!textHTML) return;\n  plaintext = plaintext.trim();\n  if (!plaintext) return;\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(textHTMLClean, 'text/html');\n  const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, node => node.parentNode && isLink(node.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT);\n  const markdown = convertToMarkdown(plaintext, walker);\n  if (markdown === plaintext) return;\n  event.stopPropagation();\n  event.preventDefault();\n  insertText(field, markdown);\n}\nfunction convertToMarkdown(plaintext, walker) {\n  var _a;\n  let currentNode = walker.firstChild();\n  let markdown = plaintext;\n  let markdownIgnoreBeforeIndex = 0;\n  let index = 0;\n  const NODE_LIMIT = 10000;\n  while (currentNode && index < NODE_LIMIT) {\n    index++;\n    const text = isLink(currentNode) ? (currentNode.textContent || '').replace(/[\\t\\n\\r ]+/g, ' ') : ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.wholeText) || '';\n    if (isEmptyString(text)) {\n      currentNode = walker.nextNode();\n      continue;\n    }\n    const markdownFoundIndex = markdown.indexOf(text, markdownIgnoreBeforeIndex);\n    if (markdownFoundIndex >= 0) {\n      if (isLink(currentNode)) {\n        const markdownLink = linkify$2(currentNode, text);\n        markdown = markdown.slice(0, markdownFoundIndex) + markdownLink + markdown.slice(markdownFoundIndex + text.length);\n        markdownIgnoreBeforeIndex = markdownFoundIndex + markdownLink.length;\n      } else {\n        markdownIgnoreBeforeIndex = markdownFoundIndex + text.length;\n      }\n    }\n    currentNode = walker.nextNode();\n  }\n  return index === NODE_LIMIT ? plaintext : markdown;\n}\nfunction isWithinUserMention(textarea) {\n  const selectionStart = textarea.selectionStart || 0;\n  if (selectionStart === 0) {\n    return false;\n  }\n  const previousChar = textarea.value.substring(selectionStart - 1, selectionStart);\n  return previousChar === '@';\n}\nfunction isEmptyString(text) {\n  return !text || (text === null || text === void 0 ? void 0 : text.trim().length) === 0;\n}\nfunction isLink(node) {\n  var _a;\n  return ((_a = node.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'a' && node.hasAttribute('href');\n}\nfunction hasHTML(transfer) {\n  return transfer.types.includes('text/html');\n}\nfunction linkify$2(element, label) {\n  const url = element.href || '';\n  let markdown = '';\n  if (isUserMention(element)) {\n    markdown = label;\n  } else if (isSpecialLink(element) || areEqualLinks(url, label)) {\n    markdown = url;\n  } else {\n    markdown = `[${label}](${url})`;\n  }\n  return markdown;\n}\nfunction isSpecialLink(link) {\n  return link.className.indexOf('commit-link') >= 0 || !!link.getAttribute('data-hovercard-type') && link.getAttribute('data-hovercard-type') !== 'user';\n}\nfunction areEqualLinks(link1, link2) {\n  link1 = link1.slice(-1) === '/' ? link1.slice(0, -1) : link1;\n  link2 = link2.slice(-1) === '/' ? link2.slice(0, -1) : link2;\n  return link1.toLowerCase() === link2.toLowerCase();\n}\nfunction isUserMention(link) {\n  var _a;\n  return ((_a = link.textContent) === null || _a === void 0 ? void 0 : _a.slice(0, 1)) === '@' && link.getAttribute('data-hovercard-type') === 'user';\n}\nfunction install$3(el) {\n  el.addEventListener('dragover', onDragover$1);\n  el.addEventListener('drop', onDrop$1);\n  el.addEventListener('paste', onPaste$3);\n}\nfunction uninstall$3(el) {\n  el.removeEventListener('dragover', onDragover$1);\n  el.removeEventListener('drop', onDrop$1);\n  el.removeEventListener('paste', onPaste$3);\n}\nfunction onDrop$1(event) {\n  const transfer = event.dataTransfer;\n  if (!transfer) return;\n  if (hasFile$1(transfer)) return;\n  if (!hasLink(transfer)) return;\n  const links = extractLinks(transfer);\n  if (!links.some(isImageLink)) return;\n  event.stopPropagation();\n  event.preventDefault();\n  const field = event.currentTarget;\n  if (!(field instanceof HTMLTextAreaElement)) return;\n  insertText(field, links.map(linkify$1).join(''));\n}\nfunction onDragover$1(event) {\n  const transfer = event.dataTransfer;\n  if (transfer) transfer.dropEffect = 'link';\n}\nfunction onPaste$3(event) {\n  const el = event.currentTarget;\n  if (shouldSkipFormatting(el)) return;\n  const transfer = event.clipboardData;\n  if (!transfer || !hasLink(transfer)) return;\n  const links = extractLinks(transfer);\n  if (!links.some(isImageLink)) return;\n  event.stopPropagation();\n  event.preventDefault();\n  const field = event.currentTarget;\n  if (!(field instanceof HTMLTextAreaElement)) return;\n  insertText(field, links.map(linkify$1).join(''));\n}\nfunction linkify$1(link) {\n  return isImageLink(link) ? `\\n![](${link})\\n` : link;\n}\nfunction hasFile$1(transfer) {\n  return Array.from(transfer.types).indexOf('Files') >= 0;\n}\nfunction hasLink(transfer) {\n  return Array.from(transfer.types).indexOf('text/uri-list') >= 0;\n}\nfunction extractLinks(transfer) {\n  return (transfer.getData('text/uri-list') || '').split('\\r\\n');\n}\nconst IMAGE_RE = /\\.(gif|png|jpe?g)$/i;\nfunction isImageLink(url) {\n  return IMAGE_RE.test(url);\n}\nconst pasteLinkAsPlainTextOverSelectedTextMap = new WeakMap();\nfunction install$2(el, optionConfig) {\n  var _a;\n  pasteLinkAsPlainTextOverSelectedTextMap.set(el, ((_a = optionConfig === null || optionConfig === void 0 ? void 0 : optionConfig.defaultPlainTextPaste) === null || _a === void 0 ? void 0 : _a.urlLinks) === true);\n  el.addEventListener('paste', onPaste$2);\n}\nfunction uninstall$2(el) {\n  el.removeEventListener('paste', onPaste$2);\n}\nfunction onPaste$2(event) {\n  var _a;\n  const el = event.currentTarget;\n  const element = el;\n  const shouldPasteAsPlainText = (_a = pasteLinkAsPlainTextOverSelectedTextMap.get(element)) !== null && _a !== void 0 ? _a : false;\n  const shouldSkipDefaultBehavior = shouldSkipFormatting(element);\n  if (!shouldPasteAsPlainText && shouldSkipDefaultBehavior || shouldPasteAsPlainText && !shouldSkipDefaultBehavior) {\n    return;\n  }\n  const transfer = event.clipboardData;\n  if (!transfer || !hasPlainText(transfer)) return;\n  const field = event.currentTarget;\n  if (!(field instanceof HTMLTextAreaElement)) return;\n  const text = transfer.getData('text/plain');\n  if (!text) return;\n  if (!isURL(text)) return;\n  if (isWithinLink(field)) return;\n  const selectedText = field.value.substring(field.selectionStart, field.selectionEnd);\n  if (!selectedText.length) return;\n  if (isURL(selectedText.trim())) return;\n  event.stopPropagation();\n  event.preventDefault();\n  insertText(field, linkify(selectedText, text.trim()));\n}\nfunction hasPlainText(transfer) {\n  return Array.from(transfer.types).includes('text/plain');\n}\nfunction isWithinLink(textarea) {\n  const selectionStart = textarea.selectionStart || 0;\n  if (selectionStart > 1) {\n    const previousChars = textarea.value.substring(selectionStart - 2, selectionStart);\n    return previousChars === '](';\n  } else {\n    return false;\n  }\n}\nfunction linkify(selectedText, text) {\n  return `[${selectedText}](${text})`;\n}\nfunction isURL(url) {\n  try {\n    const parsedURL = new URL(url);\n    return removeTrailingSlash(parsedURL.href).trim() === removeTrailingSlash(url).trim();\n  } catch (_a) {\n    return false;\n  }\n}\nfunction removeTrailingSlash(url) {\n  return url.endsWith('/') ? url.slice(0, url.length - 1) : url;\n}\nfunction install$1(el) {\n  el.addEventListener('dragover', onDragover);\n  el.addEventListener('drop', onDrop);\n  el.addEventListener('paste', onPaste$1);\n}\nfunction uninstall$1(el) {\n  el.removeEventListener('dragover', onDragover);\n  el.removeEventListener('drop', onDrop);\n  el.removeEventListener('paste', onPaste$1);\n}\nfunction onDrop(event) {\n  const transfer = event.dataTransfer;\n  if (!transfer) return;\n  if (hasFile(transfer)) return;\n  const textToPaste = generateText(transfer);\n  if (!textToPaste) return;\n  event.stopPropagation();\n  event.preventDefault();\n  const field = event.currentTarget;\n  if (field instanceof HTMLTextAreaElement) {\n    insertText(field, textToPaste);\n  }\n}\nfunction onDragover(event) {\n  const transfer = event.dataTransfer;\n  if (transfer) transfer.dropEffect = 'copy';\n}\nfunction onPaste$1(event) {\n  const el = event.currentTarget;\n  if (shouldSkipFormatting(el)) return;\n  if (!event.clipboardData) return;\n  const textToPaste = generateText(event.clipboardData);\n  if (!textToPaste) return;\n  event.stopPropagation();\n  event.preventDefault();\n  const field = event.currentTarget;\n  if (field instanceof HTMLTextAreaElement) {\n    insertText(field, textToPaste);\n  }\n}\nfunction hasFile(transfer) {\n  return Array.from(transfer.types).indexOf('Files') >= 0;\n}\nfunction columnText(column) {\n  const noBreakSpace = '\\u00A0';\n  const text = (column.textContent || '').trim().replace(/\\|/g, '\\\\|').replace(/\\n/g, ' ');\n  return text || noBreakSpace;\n}\nfunction tableHeaders(row) {\n  return Array.from(row.querySelectorAll('td, th')).map(columnText);\n}\nfunction tableMarkdown(node) {\n  const rows = Array.from(node.querySelectorAll('tr'));\n  const firstRow = rows.shift();\n  if (!firstRow) return '';\n  const headers = tableHeaders(firstRow);\n  const spacers = headers.map(() => '--');\n  const header = `${headers.join(' | ')}\\n${spacers.join(' | ')}\\n`;\n  const body = rows.map(row => {\n    return Array.from(row.querySelectorAll('td')).map(columnText).join(' | ');\n  }).join('\\n');\n  return `\\n${header}${body}\\n\\n`;\n}\nfunction generateText(transfer) {\n  if (Array.from(transfer.types).indexOf('text/html') === -1) return;\n  const html = transfer.getData('text/html');\n  if (!/<table/i.test(html)) return;\n  const parser = new DOMParser();\n  const parsedDocument = parser.parseFromString(html, 'text/html');\n  let table = parsedDocument.querySelector('table');\n  table = !table || table.closest('[data-paste-markdown-skip]') ? null : table;\n  if (!table) return;\n  const formattedTable = tableMarkdown(table);\n  return html.replace(/<meta.*?>/, '').replace(/<table[.\\S\\s]*<\\/table>/, `\\n${formattedTable}`);\n}\nfunction install(el) {\n  el.addEventListener('paste', onPaste);\n}\nfunction uninstall(el) {\n  el.removeEventListener('paste', onPaste);\n}\nfunction onPaste(event) {\n  const el = event.currentTarget;\n  if (shouldSkipFormatting(el)) return;\n  const transfer = event.clipboardData;\n  if (!transfer || !hasMarkdown(transfer)) return;\n  const field = event.currentTarget;\n  if (!(field instanceof HTMLTextAreaElement)) return;\n  const text = transfer.getData('text/x-gfm');\n  if (!text) return;\n  event.stopPropagation();\n  event.preventDefault();\n  insertText(field, text);\n}\nfunction hasMarkdown(transfer) {\n  return Array.from(transfer.types).indexOf('text/x-gfm') >= 0;\n}\nfunction subscribe(el, optionConfig) {\n  installAround(el, [install$1, install$3, install$2, install, install$4], optionConfig);\n  return {\n    unsubscribe: () => {\n      uninstall$5(el);\n      uninstall$1(el);\n      uninstall$4(el);\n      uninstall$3(el);\n      uninstall$2(el);\n      uninstall(el);\n    }\n  };\n}\nexport { install$4 as installHTML, install$3 as installImageLink, install$2 as installLink, install$1 as installTable, install as installText, subscribe, uninstall$4 as uninstallHTML, uninstall$3 as uninstallImageLink, uninstall$2 as uninstallLink, uninstall$1 as uninstallTable, uninstall as uninstallText };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}